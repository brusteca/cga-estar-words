<html>
	<head>
		<meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
		<title>ESTAR WORDS</title>
	</head>
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">

	<div class="div-fake-hidden" style="font-family: deathstar; width:0px; height:0px; overflow:hidden;}">l</div>
	<div class="div-fake-hidden" style="font-family: starjout; width:0px; height:0px; overflow:hidden;}">l</div>
	<body style="margin: 0px;">
		<table style="width: 100%; height: 100%;">
			<tr>
				<td colspan="2">
					<canvas id="glCanvas" style="width: 100%; height: 100%; display: none;">
								Sorry! Your browser does not support HTML5, please update it.
							</canvas>
					<canvas id="2dCanvas" style="width: 100%; height: 100%;">
								Sorry! Your browser does not support HTML5, please update it.
							</canvas>
				</td>
			</tr>
		</table>
	</body>

	<script type="text/javascript" src="js/libraries/jquery-3.1.1.min.js"></script>
	<script type="text/javascript" src="js/libraries/bootstrap.min.js"></script>
	<script type="text/javascript" src="js/libraries/bootbox.min.js"></script>
	<script type="text/javascript" src="js/libraries/jquery.ui.widget.js"></script>
	<script type="text/javascript" src="js/libraries/notify.js"></script>
	<script type="text/javascript" src="js/libraries/jquery.fileupload.js"></script>
	<script type="text/javascript" src="js/libraries/K3D.js"></script>
	<script type="text/javascript" src="js/libraries/math.js"></script>


	<script type="text/javascript" src="js/utils/utils.js"></script>
	<!-- twgl -->
	<script type="text/javascript" src="js/libraries/twgl-full.js"></script>
	<script type="text/javascript" src="js/libraries/quaternion.js"></script>
	<!-- <script type="text/javascript" src="js/libraries/twgl-full.min.js"></script> -->
	<!-- cannon.js -->
	<!-- <script type="text/javascript" src="js/libraries/cannon.js"></script> -->
	<script type="text/javascript" src="js/libraries/cannon.min.js"></script>

	<!-- couldn't make it work using shaders in files -->

	<!-- vertex shader -->
	<script id="3d-vertex-shader" type="x-shader/x-vertex">
		precision mediump float;

		#define light_qty 16

		attribute vec4 a_position;
		attribute vec4 a_color;
		attribute vec3 a_normal;
		attribute vec2 a_texcoord;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;

		uniform vec3 u_cameraPosition;
		uniform vec3 u_pointLightPositions[light_qty];
		// uniform vec3 u_pointLightColors[light_qty];

		varying vec4 v_color;
		varying vec3 v_normal;
		varying vec2 v_texcoord;

		varying float v_distanceToCamera;
		varying vec3 v_surfaceToLightDirections[light_qty];
		varying float v_distanceToLights[light_qty];

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// Pass the color to the fragment shader.
			v_color = a_color;
			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;
			v_texcoord = a_texcoord;

			// compute the world position of the surface
			vec3 surfaceWorldPosition = (u_world * a_position).xyz;

			v_distanceToCamera = distance(surfaceWorldPosition, u_cameraPosition);
			// compute the vector of the surface to the light
			// and pass it to the fragment shader
			for (int ii = 0; ii < light_qty; ++ii) {
				v_surfaceToLightDirections[ii] = u_pointLightPositions[ii] - surfaceWorldPosition;
				v_distanceToLights[ii] = distance(surfaceWorldPosition, u_pointLightPositions[ii]);
			}

		}
	</script>
	<!-- fragment shader -->
	<script id="3d-fragment-shader" type="x-shader/x-fragment">
		precision mediump float;

		#define light_qty 16

		const float c_maxDistance = 8000.0;
		// skyblue (135, 206, 235)
		// const vec4 c_atmosphereColor = vec4(0.5294, 0.8078, 0.9215, 1);
		const vec4 c_atmosphereColor = vec4(0.0, 0.0, 0.0, 1);
		const vec3 c_backgroundLight = vec3(0.3, 0.3, 0.3);
		// light attenuation
		const float constAtt = 0.03;
		const float linearAtt = 0.2;
		const float quadAtt = 0.012;

		uniform vec3 u_reverseLightDirection;
		// The texture.
		uniform sampler2D u_texture;

		uniform bool u_useTexture;
		uniform vec3 u_pointLightColors[light_qty];
		uniform float u_pointLightMaxDistances[light_qty];

		varying vec4 v_color;
		varying vec3 v_normal;
		varying vec2 v_texcoord;
		varying float v_distanceToCamera;
		varying vec3 v_surfaceToLightDirections[light_qty];
		varying float v_distanceToLights[light_qty];

		void main() {
			vec4 fragColor;
			// because v_normal is a varying it's interpolated
			// we it will not be a uint vector. Normalizing it
			// will make it a unit vector again
			vec3 normalSurfaceToLightDirections[light_qty];
			vec3 normal = normalize(v_normal);
			for (int ii = 0; ii < light_qty; ++ii) {
				normalSurfaceToLightDirections[ii] = normalize(v_surfaceToLightDirections[ii]);
			}
			//float lightComponent = dot(normal, u_reverseLightDirection) * 0.3;

			vec3 light = c_backgroundLight;
			for (int ii = 0; ii < light_qty; ++ii) {
				// float attFactor = u_pointLightIntensities[ii] * min(
				// 	1.0,
				// 	1.0 / (constAtt + linearAtt * v_distanceToLights[ii] + quadAtt * pow(v_distanceToLights[ii], 2.0))
				// );
				light += u_pointLightColors[ii].rgb * dot(normal, normalSurfaceToLightDirections[ii]);
				if (v_distanceToLights[ii] < u_pointLightMaxDistances[ii]) {
				}
			}

			if (u_useTexture) {
				fragColor = texture2D(u_texture, v_texcoord);
			} else {
				fragColor = v_color;
			}

			// Lets multiply just the color portion (not the alpha)
			// by the light
			fragColor.rgb *= light;

			float mix_percent = clamp(v_distanceToCamera / c_maxDistance, 0.0, 1.0);

			fragColor = mix(fragColor, c_atmosphereColor, mix_percent);

			gl_FragColor = fragColor;
		}
	</script>

	<!-- vertex shader -->
	<script id="3d-vertex-shader-skydome" type="x-shader/x-vertex">
		attribute vec4 a_position;
		attribute vec4 a_color;
		attribute vec3 a_normal;
		attribute vec2 a_texcoord;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;

		varying vec4 v_color;
		varying vec3 v_normal;
		varying vec2 v_texcoord;

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// Pass the color to the fragment shader.
			v_color = a_color;
			v_texcoord = a_texcoord;

			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;
		}
	</script>
	<script id="3d-fragment-shader-skydome" type="x-shader/x-fragment">
		precision mediump float;

		uniform sampler2D u_texture;

		// Passed in from the vertex shader.
		varying vec4 v_color;
		varying vec3 v_normal;
		varying vec2 v_texcoord;

		void main() {
			gl_FragColor = texture2D(u_texture, v_texcoord);
		}
	</script>

	<script id="3d-vertex-shader-laser" type="x-shader/x-vertex">
		attribute vec4 a_position;
		attribute vec3 a_normal;

		uniform vec4 u_color;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;

		varying vec4 v_color;
		varying vec3 v_normal;

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// Pass the color to the fragment shader.
			v_color = u_color;

			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;
		}
	</script>
	<script id="3d-fragment-shader-laser" type="x-shader/x-fragment">
		precision mediump float;

		// Passed in from the vertex shader.
		varying vec4 v_color;
		varying vec3 v_normal; // gonna need this

		void main() {
			gl_FragColor = v_color;
		}
	</script>

	<!-- vertex shader -->
	<script id="3d-vertex-shader-terrain" type="x-shader/x-vertex">
		attribute vec4 a_position;
		attribute vec4 a_color;
		attribute vec3 a_normal;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;

		varying vec4 v_color;
		varying vec3 v_normal;

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// Pass the color to the fragment shader.
			v_color = a_color;
			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;

			// compute the world position of the surfoace
			vec3 surfaceWorldPosition = (u_world * a_position).xyz;
			// compute the vector of the surface to the light
			// and pass it to the fragment shader
		}
	</script>
	<!-- fragment shader -->
	<script id="3d-fragment-shader-terrain" type="x-shader/x-fragment">
		precision mediump float;


		varying vec4 v_color;
		varying vec3 v_normal;

		void main() {
			// because v_normal is a varying it's interpolated
			// we it will not be a uint vector. Normalizing it
			// will make it a unit vector again

			vec3 normal = normalize(v_normal);
			//float lightComponent = dot(normal, u_reverseLightDirection) * 0.3;


			gl_FragColor = v_color;
		}
	</script>




	<script type="text/javascript" src="js/transform.js"></script>
	<script type="text/javascript" src="js/modelManager.js"></script>
	<script type="text/javascript" src="js/textureManager.js"></script>
	<script type="text/javascript" src="js/shaderManager.js"></script>
	<!-- Components -->
	<script type="text/javascript" src="js/components/inputComponent.js"></script>
	<script type="text/javascript" src="js/components/keyboardInputComponent.js"></script>
	<script type="text/javascript" src="js/components/scriptInputComponent.js"></script>

	<script type="text/javascript" src="js/components/worldInputComponent.js"></script>

	<script type="text/javascript" src="js/components/motionComponent.js"></script>
	<script type="text/javascript" src="js/components/spaceShipMotionComponent.js"></script>
	<script type="text/javascript" src="js/components/behaviorComponent.js"></script>
	<script type="text/javascript" src="js/components/firstPersonFlyBehaviorComponent.js"></script>
	<script type="text/javascript" src="js/components/laserShootingBehaviorComponent.js"></script>

	<script type="text/javascript" src="js/components/physicsComponent.js"></script>

	<!-- Game Objects -->
	<script type="text/javascript" src="js/gameObjects/gameObject.js"></script>
	<script type="text/javascript" src="js/gameObjects/camera.js"></script>

	<!-- Shapes -->
	<script type="text/javascript" src="js/gameObjects/skyDome.js"></script>
	<script type="text/javascript" src="js/gameObjects/model.js"></script>
	<script type="text/javascript" src="js/gameObjects/laserShot.js"></script>
	<script type="text/javascript" src="js/gameObjects/ship.js"></script>
	<script type="text/javascript" src="js/gameObjects/efe.js"></script>
	<script type="text/javascript" src="js/gameObjects/sphere.js"></script>
	<script type="text/javascript" src="js/gameObjects/floor.js"></script>
	<script type="text/javascript" src="js/gameObjects/terrain.js"></script>
	<script type="text/javascript" src="js/gameObjects/decorations.js"></script>
	<!-- Lights -->
	<script type="text/javascript" src="js/gameObjects/light.js"></script>

	<script type="text/javascript" src="js/world.js"></script>
	<script type="text/javascript" src="js/main.js"></script>
	<script type="text/javascript" src="js/config.js"></script>

	<script type="text/javascript">

		loadResources(main);
		//main();
		// requestAnimationFrame(mainLoop);

	</script>
</html>
